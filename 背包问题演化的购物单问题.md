---
#标题
title: 背包问题演化的购物单问题
date: 2018-6-25  20:34:23
---
基本的背包问题是指有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。本篇博客将讲解由背包问题可衍生出的购物单问题。 <!--more-->

## 背包问题

**背包问题**：指有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。

**基本思路**：这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。
用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：
f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}
这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为f[i-1][v]；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是f[i-1][v-c[i]]再加上通过放入第i件物品获得的价值w[i]。

## 购物单问题

**题目描述**:王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

|-|-|
|主件|附件|
|电脑|打印机，扫描仪|
|书柜|图书|
|书桌|台灯，文具|
|工作椅|无|

如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 ~ 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。
设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为：
v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ] 。（其中 '*'为乘号）
请你帮助王强设计一个满足要求的购物单。

**输入描述**：输入的第 1 行，为两个正整数，用一个空格隔开：N m
（其中 N （ <32000 ）表示总钱数， m （ <60 ）为希望购买物品的个数。）
从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q
（其中 v 表示该物品的价格（ v<10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q>0 ，表示该物品为附件， q 是所属主件的编号）

**输出描述**：输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ <200000 ）。

**示例**：
输入：
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0
输出：
2200

```python
N,m = map(int,input().split(' '))
data = []
for i in range(m):
    data.append(list(map(int,input().split(' '))))
a = [[0]*(N+1) for n in range(m+1)]
for i in range(1,m+1):
    for j in range(10,N+1,10):
        if data[i-1][2] == 0:#zhujian
            if data[i-1][0]<=j:
                a[i][j] = max(a[i-1][j],a[i-1][j-data[i-1][0]]+data[i-1][0]*data[i-1][1])
        elif data[i-1][2] != 0:
            if data[i-1][0]+data[data[i-1][2]-1][0]<=j :
                a[i][j] = max(a[i-1][j],a[i-1][j-data[i-1][0]-data[data[i-1][2]-1][0]]+data[i-1][0]*data[i-1][1]+data[data[i-1][2]-1][0]*data[data[i-1][2]-1][0])
print(a[m][int(N/10)*10])
```

## Python map()函数

**描述**
map() 会根据提供的函数对指定序列做映射。
第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。

**语法**
map() 函数语法：

```python
map(function, iterable, ...)
```

**参数**
function -- 函数，有两个参数
iterable -- 一个或多个序列

**实例**
以下实例展示了 map() 的使用方法：

```python
>>>def square(x) :            # 计算平方数
...     return x ** 2
... 
>>> map(square, [1,2,3,4,5])   # 计算列表各个元素的平方
[1, 4, 9, 16, 25]
>>> map(lambda x: x ** 2, [1, 2, 3, 4, 5])  # 使用 lambda 匿名函数
[1, 4, 9, 16, 25]
 
# 提供了两个列表，对相同位置的列表数据进行相加
>>> map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])
[3, 7, 11, 15, 19]
```